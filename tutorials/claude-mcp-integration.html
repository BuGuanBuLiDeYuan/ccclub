<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude MCP é›†æˆæŒ‡å—ï¼šæ¨¡å‹ä¸Šä¸‹æ–‡åè®®æ·±åº¦å®è·µ - Claude Code Club</title>
    <meta name="description" content="æ·±å…¥äº†è§£Claude MCPï¼ˆModel Context Protocolï¼‰é›†æˆï¼ŒæŒæ¡å¤šæ¨¡å‹åä½œå’Œä¸Šä¸‹æ–‡å…±äº«çš„æœ€ä½³å®è·µ">
    <meta name="keywords" content="Claude MCP, Model Context Protocol, æ¨¡å‹åä½œ, ä¸Šä¸‹æ–‡å…±äº«, AIé›†æˆ">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ccclub.club/tutorials/claude-mcp-integration.html">
    <meta property="og:title" content="Claude MCP é›†æˆæŒ‡å—ï¼šæ¨¡å‹ä¸Šä¸‹æ–‡åè®®æ·±åº¦å®è·µ">
    <meta property="og:description" content="æ·±å…¥äº†è§£Claude MCPé›†æˆï¼ŒæŒæ¡å¤šæ¨¡å‹åä½œå’Œä¸Šä¸‹æ–‡å…±äº«çš„æœ€ä½³å®è·µ">
    <meta property="og:image" content="https://ccclub.club/assets/logo-origin.svg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ccclub.club/tutorials/claude-mcp-integration.html">
    <meta property="twitter:title" content="Claude MCP é›†æˆæŒ‡å—ï¼šæ¨¡å‹ä¸Šä¸‹æ–‡åè®®æ·±åº¦å®è·µ">
    <meta property="twitter:description" content="æ·±å…¥äº†è§£Claude MCPé›†æˆï¼ŒæŒæ¡å¤šæ¨¡å‹åä½œå’Œä¸Šä¸‹æ–‡å…±äº«çš„æœ€ä½³å®è·µ">
    <meta property="twitter:image" content="https://ccclub.club/assets/logo-origin.svg">

    <!-- WeChat -->
    <meta name="wechat:title" content="Claude MCP é›†æˆæŒ‡å—ï¼šæ¨¡å‹ä¸Šä¸‹æ–‡åè®®æ·±åº¦å®è·µ">
    <meta name="wechat:description" content="æ·±å…¥äº†è§£Claude MCPé›†æˆï¼ŒæŒæ¡å¤šæ¨¡å‹åä½œå’Œä¸Šä¸‹æ–‡å…±äº«çš„æœ€ä½³å®è·µ">
    <meta name="wechat:image" content="https://ccclub.club/assets/logo-origin.svg">

    <link rel="stylesheet" href="../styles/main.css">
    <link rel="stylesheet" href="../styles/tutorial.css">
    <link rel="icon" type="image/svg+xml" href="../assets/logo-icon.svg">
</head>

<body>
        <header class="header">
        <nav class="nav">
            <div class="nav-container">
                <a href="../" class="logo">
                    <img src="../assets/logo-simple.png" alt="Claude Code Club" class="logo-img">
                </a>
                <ul class="nav-menu">
                    <li><a href="../#home">é¦–é¡µ</a></li>
                    <li><a href="../#tutorials">æ•™ç¨‹</a></li>
                    <li><a href="../#examples">ç¤ºä¾‹</a></li>
                    <li><a href="../community.html">ç¤¾åŒº</a></li>
                    <li><a href="../about.html">å…³äº</a></li>
                    <li><a href="../subscription.html">è®¢é˜…</a></li>
                </ul>
                <div class="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </nav>
    </header>

    <main class="tutorial-content">
        <div class="container">
            <article>
                <header class="tutorial-header">
                    <h1>Claude MCP é›†æˆæŒ‡å—ï¼šæ¨¡å‹ä¸Šä¸‹æ–‡åè®®æ·±åº¦å®è·µ</h1>
                    <div class="tutorial-meta">
                        <span class="difficulty advanced">é«˜çº§</span>
                        <span class="duration">é˜…è¯»æ—¶é—´: 18åˆ†é’Ÿ</span>
                        <span class="category">åè®®é›†æˆ</span>
                    </div>
                    <p class="tutorial-description">
                        æ·±å…¥äº†è§£ Claude MCPï¼ˆModel Context Protocolï¼‰çš„æ ¸å¿ƒæ¦‚å¿µå’Œå®è·µåº”ç”¨ï¼ŒæŒæ¡å¤šæ¨¡å‹åä½œå’Œä¸Šä¸‹æ–‡å…±äº«çš„å…ˆè¿›æŠ€æœ¯ã€‚
                    </p>
                </header>

                <div class="tutorial-body">
                    <section class="tutorial-section">
                        <h2>MCP åè®®æ¦‚è¿°</h2>
                        <p>Model Context Protocol (MCP) æ˜¯ Anthropic å¼€å‘çš„å¼€æ”¾æ ‡å‡†ï¼Œæ—¨åœ¨å®ç° AI åº”ç”¨ä¸å¤–éƒ¨æ•°æ®æºå’Œå·¥å…·çš„å®‰å…¨è¿æ¥ã€‚MCP ä½¿å¾— Claude
                            èƒ½å¤Ÿè®¿é—®å®æ—¶ä¿¡æ¯ã€æ‰§è¡Œå¤æ‚æ“ä½œï¼Œå¹¶ä¸å„ç§ç³»ç»Ÿæ— ç¼é›†æˆã€‚</p>

                        <div class="mcp-benefits">
                            <div class="benefit-card">
                                <h3>ğŸ”— ç»Ÿä¸€è¿æ¥</h3>
                                <p>æ ‡å‡†åŒ–çš„æ¥å£åè®®ï¼Œç®€åŒ– AI åº”ç”¨ä¸å¤–éƒ¨ç³»ç»Ÿçš„é›†æˆ</p>
                                <ul>
                                    <li>æ•°æ®åº“è¿æ¥</li>
                                    <li>API é›†æˆ</li>
                                    <li>æ–‡ä»¶ç³»ç»Ÿè®¿é—®</li>
                                    <li>äº‘æœåŠ¡å¯¹æ¥</li>
                                </ul>
                            </div>
                            <div class="benefit-card">
                                <h3>ğŸ›¡ï¸ å®‰å…¨å¯æ§</h3>
                                <p>å†…ç½®å®‰å…¨æœºåˆ¶ï¼Œç¡®ä¿æ•°æ®è®¿é—®çš„å®‰å…¨æ€§å’Œå¯æ§æ€§</p>
                                <ul>
                                    <li>æƒé™ç®¡ç†</li>
                                    <li>è®¿é—®æ§åˆ¶</li>
                                    <li>æ•°æ®åŠ å¯†</li>
                                    <li>å®¡è®¡æ—¥å¿—</li>
                                </ul>
                            </div>
                            <div class="benefit-card">
                                <h3>âš¡ é«˜æ•ˆåä½œ</h3>
                                <p>ä¼˜åŒ–çš„ä¸Šä¸‹æ–‡å…±äº«æœºåˆ¶ï¼Œæå‡å¤šæ¨¡å‹åä½œæ•ˆç‡</p>
                                <ul>
                                    <li>ä¸Šä¸‹æ–‡ç¼“å­˜</li>
                                    <li>æ™ºèƒ½è·¯ç”±</li>
                                    <li>è´Ÿè½½å‡è¡¡</li>
                                    <li>æ•…éšœæ¢å¤</li>
                                </ul>
                            </div>
                        </div>
                    </section>

                    <section class="tutorial-section">
                        <h2>MCP æ¶æ„ä¸æ ¸å¿ƒç»„ä»¶</h2>

                        <h3>ç³»ç»Ÿæ¶æ„</h3>
                        <div class="mcp-architecture">
                            <div class="arch-component client">
                                <h4>ğŸ–¥ï¸ MCP Client</h4>
                                <p>Claude Desktop, IDE æ’ä»¶ç­‰</p>
                            </div>
                            <div class="arch-arrow">â†•ï¸</div>
                            <div class="arch-component protocol">
                                <h4>ğŸ“¡ MCP Protocol</h4>
                                <p>æ ‡å‡†åŒ–é€šä¿¡åè®®</p>
                            </div>
                            <div class="arch-arrow">â†•ï¸</div>
                            <div class="arch-component server">
                                <h4>ğŸ”§ MCP Server</h4>
                                <p>æ•°æ®æºå’Œå·¥å…·è¿æ¥å™¨</p>
                            </div>
                        </div>

                        <h3>æ ¸å¿ƒæ¦‚å¿µ</h3>
                        <div class="core-concepts">
                            <div class="concept-item">
                                <h4>ğŸ“‹ Resources</h4>
                                <p>MCP æœåŠ¡å™¨æä¾›çš„æ•°æ®èµ„æºï¼Œå¦‚æ–‡ä»¶ã€æ•°æ®åº“è®°å½•ã€API å“åº”ç­‰</p>
                                <pre><code>{
  "uri": "file:///path/to/document.txt",
  "name": "Project Documentation",
  "description": "Main project documentation file",
  "mimeType": "text/plain"
}</code></pre>
                            </div>

                            <div class="concept-item">
                                <h4>ğŸ› ï¸ Tools</h4>
                                <p>Claude å¯ä»¥è°ƒç”¨çš„åŠŸèƒ½å·¥å…·ï¼Œå¦‚æ•°æ®æŸ¥è¯¢ã€æ–‡ä»¶æ“ä½œã€API è°ƒç”¨ç­‰</p>
                                <pre><code>{
  "name": "search_database",
  "description": "Search the customer database",
  "inputSchema": {
    "type": "object",
    "properties": {
      "query": {"type": "string"},
      "limit": {"type": "number", "default": 10}
    }
  }
}</code></pre>
                            </div>

                            <div class="concept-item">
                                <h4>ğŸ’¬ Prompts</h4>
                                <p>é¢„å®šä¹‰çš„æç¤ºæ¨¡æ¿ï¼Œç”¨äºæ ‡å‡†åŒ–å¸¸è§çš„äº¤äº’æ¨¡å¼</p>
                                <pre><code>{
  "name": "analyze_data",
  "description": "Analyze dataset with specific focus",
  "arguments": [
    {
      "name": "dataset",
      "description": "Path to the dataset",
      "required": true
    },
    {
      "name": "focus_area",
      "description": "Analysis focus area",
      "required": false
    }
  ]
}</code></pre>
                            </div>
                        </div>
                    </section>

                    <section class="tutorial-section">
                        <h2>MCP æœåŠ¡å™¨å¼€å‘å®æˆ˜</h2>

                        <h3>åŸºç¡€æœåŠ¡å™¨å®ç°</h3>
                        <pre><code># mcp_server.py
import asyncio
import json
from typing import Any, Dict, List
from mcp import Server, types
from mcp.server.models import InitializationOptions

class CustomMCPServer:
    def __init__(self):
        self.server = Server("custom-mcp-server")
        self.setup_handlers()
    
    def setup_handlers(self):
        """è®¾ç½® MCP å¤„ç†å™¨"""
        
        @self.server.list_resources()
        async def handle_list_resources() -> List[types.Resource]:
            """åˆ—å‡ºå¯ç”¨èµ„æº"""
            return [
                types.Resource(
                    uri="custom://database/users",
                    name="User Database",
                    description="Customer user database",
                    mimeType="application/json"
                ),
                types.Resource(
                    uri="custom://files/logs",
                    name="Application Logs",
                    description="System application logs",
                    mimeType="text/plain"
                )
            ]
        
        @self.server.read_resource()
        async def handle_read_resource(uri: str) -> str:
            """è¯»å–æŒ‡å®šèµ„æº"""
            if uri == "custom://database/users":
                # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
                users = await self.query_user_database()
                return json.dumps(users, indent=2)
            elif uri == "custom://files/logs":
                # è¯»å–æ—¥å¿—æ–‡ä»¶
                return await self.read_log_files()
            else:
                raise ValueError(f"Unknown resource: {uri}")
        
        @self.server.list_tools()
        async def handle_list_tools() -> List[types.Tool]:
            """åˆ—å‡ºå¯ç”¨å·¥å…·"""
            return [
                types.Tool(
                    name="search_users",
                    description="Search users in the database",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "query": {
                                "type": "string",
                                "description": "Search query"
                            },
                            "limit": {
                                "type": "number",
                                "description": "Maximum results",
                                "default": 10
                            }
                        },
                        "required": ["query"]
                    }
                ),
                types.Tool(
                    name="create_user",
                    description="Create a new user",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "name": {"type": "string"},
                            "email": {"type": "string"},
                            "role": {"type": "string", "default": "user"}
                        },
                        "required": ["name", "email"]
                    }
                )
            ]
        
        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Dict[str, Any]) -> List[types.TextContent]:
            """æ‰§è¡Œå·¥å…·è°ƒç”¨"""
            if name == "search_users":
                results = await self.search_users(
                    arguments["query"], 
                    arguments.get("limit", 10)
                )
                return [types.TextContent(
                    type="text",
                    text=json.dumps(results, indent=2)
                )]
            
            elif name == "create_user":
                user = await self.create_user(
                    arguments["name"],
                    arguments["email"],
                    arguments.get("role", "user")
                )
                return [types.TextContent(
                    type="text",
                    text=f"Created user: {json.dumps(user, indent=2)}"
                )]
            
            else:
                raise ValueError(f"Unknown tool: {name}")
    
    async def query_user_database(self) -> List[Dict]:
        """æŸ¥è¯¢ç”¨æˆ·æ•°æ®åº“"""
        # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
        return [
            {"id": 1, "name": "Alice", "email": "alice@example.com", "role": "admin"},
            {"id": 2, "name": "Bob", "email": "bob@example.com", "role": "user"},
            {"id": 3, "name": "Charlie", "email": "charlie@example.com", "role": "user"}
        ]
    
    async def search_users(self, query: str, limit: int) -> List[Dict]:
        """æœç´¢ç”¨æˆ·"""
        all_users = await self.query_user_database()
        filtered_users = [
            user for user in all_users 
            if query.lower() in user["name"].lower() or query.lower() in user["email"].lower()
        ]
        return filtered_users[:limit]
    
    async def create_user(self, name: str, email: str, role: str) -> Dict:
        """åˆ›å»ºæ–°ç”¨æˆ·"""
        # æ¨¡æ‹Ÿç”¨æˆ·åˆ›å»º
        new_user = {
            "id": len(await self.query_user_database()) + 1,
            "name": name,
            "email": email,
            "role": role
        }
        # è¿™é‡Œåº”è¯¥æ˜¯å®é™…çš„æ•°æ®åº“æ’å…¥æ“ä½œ
        return new_user
    
    async def read_log_files(self) -> str:
        """è¯»å–æ—¥å¿—æ–‡ä»¶"""
        # æ¨¡æ‹Ÿæ—¥å¿—è¯»å–
        return """
2024-01-15 10:30:00 INFO: Application started
2024-01-15 10:30:05 INFO: Database connection established
2024-01-15 10:31:00 INFO: User login: alice@example.com
2024-01-15 10:32:15 WARN: High memory usage detected
2024-01-15 10:33:00 INFO: User logout: alice@example.com
        """.strip()
    
    async def run(self, transport_type: str = "stdio"):
        """è¿è¡Œ MCP æœåŠ¡å™¨"""
        if transport_type == "stdio":
            from mcp.server.stdio import stdio_server
            async with stdio_server() as (read_stream, write_stream):
                await self.server.run(
                    read_stream,
                    write_stream,
                    InitializationOptions(
                        server_name="custom-mcp-server",
                        server_version="1.0.0",
                        capabilities=self.server.get_capabilities()
                    )
                )

# å¯åŠ¨æœåŠ¡å™¨
if __name__ == "__main__":
    server = CustomMCPServer()
    asyncio.run(server.run())</code></pre>

                        <h3>é«˜çº§åŠŸèƒ½å®ç°</h3>
                        <pre><code># advanced_mcp_server.py
import asyncio
import aiohttp
import sqlite3
from datetime import datetime
from typing import Optional

class AdvancedMCPServer(CustomMCPServer):
    def __init__(self, db_path: str = "mcp_data.db"):
        super().__init__()
        self.db_path = db_path
        self.init_database()
        self.setup_advanced_handlers()
    
    def init_database(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                email TEXT UNIQUE NOT NULL,
                role TEXT DEFAULT 'user',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS api_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                endpoint TEXT NOT NULL,
                method TEXT NOT NULL,
                status_code INTEGER,
                response_time REAL,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        conn.commit()
        conn.close()
    
    def setup_advanced_handlers(self):
        """è®¾ç½®é«˜çº§å¤„ç†å™¨"""
        
        @self.server.list_tools()
        async def handle_advanced_tools() -> List[types.Tool]:
            """æ‰©å±•å·¥å…·åˆ—è¡¨"""
            basic_tools = await super().handle_list_tools()
            
            advanced_tools = [
                types.Tool(
                    name="fetch_api_data",
                    description="Fetch data from external API",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "url": {"type": "string"},
                            "method": {"type": "string", "default": "GET"},
                            "headers": {"type": "object"},
                            "params": {"type": "object"}
                        },
                        "required": ["url"]
                    }
                ),
                types.Tool(
                    name="analyze_logs",
                    description="Analyze API usage logs",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "start_date": {"type": "string"},
                            "end_date": {"type": "string"},
                            "endpoint_filter": {"type": "string"}
                        }
                    }
                ),
                types.Tool(
                    name="generate_report",
                    description="Generate usage report",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "report_type": {
                                "type": "string",
                                "enum": ["user_activity", "api_usage", "error_summary"]
                            },
                            "format": {
                                "type": "string",
                                "enum": ["json", "csv", "html"],
                                "default": "json"
                            }
                        },
                        "required": ["report_type"]
                    }
                )
            ]
            
            return basic_tools + advanced_tools
        
        @self.server.call_tool()
        async def handle_advanced_tool_calls(name: str, arguments: Dict[str, Any]) -> List[types.TextContent]:
            """å¤„ç†é«˜çº§å·¥å…·è°ƒç”¨"""
            
            if name == "fetch_api_data":
                return await self.fetch_api_data(arguments)
            elif name == "analyze_logs":
                return await self.analyze_logs(arguments)
            elif name == "generate_report":
                return await self.generate_report(arguments)
            else:
                # å›é€€åˆ°åŸºç¡€å·¥å…·å¤„ç†
                return await super().handle_call_tool(name, arguments)
    
    async def fetch_api_data(self, args: Dict[str, Any]) -> List[types.TextContent]:
        """è·å–å¤–éƒ¨ API æ•°æ®"""
        url = args["url"]
        method = args.get("method", "GET")
        headers = args.get("headers", {})
        params = args.get("params", {})
        
        start_time = datetime.now()
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.request(
                    method, url, headers=headers, params=params
                ) as response:
                    data = await response.text()
                    status_code = response.status
                    
                    # è®°å½• API è°ƒç”¨æ—¥å¿—
                    response_time = (datetime.now() - start_time).total_seconds()
                    await self.log_api_call(url, method, status_code, response_time)
                    
                    return [types.TextContent(
                        type="text",
                        text=f"API Response (Status: {status_code}):\n{data}"
                    )]
        
        except Exception as e:
            await self.log_api_call(url, method, 0, 0)
            return [types.TextContent(
                type="text",
                text=f"API call failed: {str(e)}"
            )]
    
    async def log_api_call(self, endpoint: str, method: str, status_code: int, response_time: float):
        """è®°å½• API è°ƒç”¨æ—¥å¿—"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO api_logs (endpoint, method, status_code, response_time)
            VALUES (?, ?, ?, ?)
        """, (endpoint, method, status_code, response_time))
        
        conn.commit()
        conn.close()
    
    async def analyze_logs(self, args: Dict[str, Any]) -> List[types.TextContent]:
        """åˆ†æ API ä½¿ç”¨æ—¥å¿—"""
        start_date = args.get("start_date")
        end_date = args.get("end_date")
        endpoint_filter = args.get("endpoint_filter")
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = "SELECT * FROM api_logs WHERE 1=1"
        params = []
        
        if start_date:
            query += " AND timestamp >= ?"
            params.append(start_date)
        
        if end_date:
            query += " AND timestamp <= ?"
            params.append(end_date)
        
        if endpoint_filter:
            query += " AND endpoint LIKE ?"
            params.append(f"%{endpoint_filter}%")
        
        cursor.execute(query, params)
        logs = cursor.fetchall()
        
        # åˆ†æç»Ÿè®¡
        total_calls = len(logs)
        success_calls = len([log for log in logs if 200 <= log[3] < 300])
        avg_response_time = sum(log[4] for log in logs) / total_calls if total_calls > 0 else 0
        
        analysis = {
            "total_calls": total_calls,
            "success_rate": success_calls / total_calls if total_calls > 0 else 0,
            "average_response_time": avg_response_time,
            "recent_logs": logs[-10:]  # æœ€è¿‘10æ¡è®°å½•
        }
        
        conn.close()
        
        return [types.TextContent(
            type="text",
            text=json.dumps(analysis, indent=2, default=str)
        )]
    
    async def generate_report(self, args: Dict[str, Any]) -> List[types.TextContent]:
        """ç”Ÿæˆä½¿ç”¨æŠ¥å‘Š"""
        report_type = args["report_type"]
        format_type = args.get("format", "json")
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        if report_type == "user_activity":
            cursor.execute("SELECT COUNT(*) as total_users FROM users")
            user_count = cursor.fetchone()[0]
            
            cursor.execute("""
                SELECT role, COUNT(*) as count 
                FROM users 
                GROUP BY role
            """)
            role_distribution = cursor.fetchall()
            
            report_data = {
                "total_users": user_count,
                "role_distribution": dict(role_distribution),
                "generated_at": datetime.now().isoformat()
            }
        
        elif report_type == "api_usage":
            cursor.execute("""
                SELECT 
                    COUNT(*) as total_calls,
                    AVG(response_time) as avg_response_time,
                    COUNT(CASE WHEN status_code >= 200 AND status_code < 300 THEN 1 END) as success_calls
                FROM api_logs
            """)
            stats = cursor.fetchone()
            
            report_data = {
                "total_api_calls": stats[0],
                "average_response_time": stats[1],
                "success_calls": stats[2],
                "success_rate": stats[2] / stats[0] if stats[0] > 0 else 0,
                "generated_at": datetime.now().isoformat()
            }
        
        else:  # error_summary
            cursor.execute("""
                SELECT status_code, COUNT(*) as count
                FROM api_logs
                WHERE status_code >= 400
                GROUP BY status_code
                ORDER BY count DESC
            """)
            error_stats = cursor.fetchall()
            
            report_data = {
                "error_distribution": dict(error_stats),
                "total_errors": sum(count for _, count in error_stats),
                "generated_at": datetime.now().isoformat()
            }
        
        conn.close()
        
        if format_type == "json":
            report_text = json.dumps(report_data, indent=2)
        elif format_type == "csv":
            # ç®€åŒ–çš„ CSV æ ¼å¼
            report_text = "key,value\n" + "\n".join(
                f"{k},{v}" for k, v in report_data.items()
            )
        else:  # html
            report_text = f"""
            <html>
            <head><title>{report_type.title()} Report</title></head>
            <body>
                <h1>{report_type.title()} Report</h1>
                <pre>{json.dumps(report_data, indent=2)}</pre>
</body>

</html>
"""

return [types.TextContent(
type="text",
text=report_text
)]</code></pre>
</section>

<section class="tutorial-section">
    <h2>å®¢æˆ·ç«¯é›†æˆä¸é…ç½®</h2>

    <h3>Claude Desktop é…ç½®</h3>
    <pre><code># ~/.claude_desktop_config.json
{
  "mcpServers": {
    "custom-server": {
      "command": "python",
      "args": ["/path/to/mcp_server.py"],
      "env": {
        "DATABASE_URL": "sqlite:///mcp_data.db",
        "LOG_LEVEL": "INFO"
      }
    },
    "filesystem": {
      "command": "uvx",
      "args": ["mcp-server-filesystem", "/path/to/allowed/directory"],
      "env": {}
    },
    "github": {
      "command": "uvx",
      "args": ["mcp-server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "your_token_here"
      }
    }
  }
}</code></pre>

    <h3>ç¼–ç¨‹å¼å®¢æˆ·ç«¯</h3>
    <pre><code># mcp_client.py
import asyncio
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

class MCPClient:
    def __init__(self):
        self.session = None
    
    async def connect_to_server(self, server_params: StdioServerParameters):
        """è¿æ¥åˆ° MCP æœåŠ¡å™¨"""
        self.session = await stdio_client(server_params)
        
        # åˆå§‹åŒ–ä¼šè¯
        await self.session.initialize()
        
        print("Connected to MCP server successfully!")
    
    async def list_available_resources(self):
        """åˆ—å‡ºå¯ç”¨èµ„æº"""
        if not self.session:
            raise RuntimeError("Not connected to server")
        
        resources = await self.session.list_resources()
        print("Available resources:")
        for resource in resources:
            print(f"  - {resource.name}: {resource.uri}")
        
        return resources
    
    async def list_available_tools(self):
        """åˆ—å‡ºå¯ç”¨å·¥å…·"""
        if not self.session:
            raise RuntimeError("Not connected to server")
        
        tools = await self.session.list_tools()
        print("Available tools:")
        for tool in tools:
            print(f"  - {tool.name}: {tool.description}")
        
        return tools
    
    async def call_tool(self, tool_name: str, arguments: dict):
        """è°ƒç”¨å·¥å…·"""
        if not self.session:
            raise RuntimeError("Not connected to server")
        
        result = await self.session.call_tool(tool_name, arguments)
        return result
    
    async def read_resource(self, uri: str):
        """è¯»å–èµ„æº"""
        if not self.session:
            raise RuntimeError("Not connected to server")
        
        content = await self.session.read_resource(uri)
        return content
    
    async def close(self):
        """å…³é—­è¿æ¥"""
        if self.session:
            await self.session.close()

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    client = MCPClient()
    
    # è¿æ¥åˆ°æœåŠ¡å™¨
    server_params = StdioServerParameters(
        command="python",
        args=["mcp_server.py"]
    )
    
    await client.connect_to_server(server_params)
    
    try:
        # åˆ—å‡ºèµ„æºå’Œå·¥å…·
        await client.list_available_resources()
        await client.list_available_tools()
        
        # è°ƒç”¨å·¥å…·
        search_result = await client.call_tool("search_users", {
            "query": "alice",
            "limit": 5
        })
        print("Search result:", search_result)
        
        # è¯»å–èµ„æº
        user_data = await client.read_resource("custom://database/users")
        print("User data:", user_data)
        
    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(main())</code></pre>
</section>

<section class="tutorial-section">
    <h2>å®‰å…¨æ€§ä¸æœ€ä½³å®è·µ</h2>

    <h3>å®‰å…¨é…ç½®</h3>
    <div class="security-practices">
        <div class="practice-item">
            <h4>ğŸ” è®¤è¯ä¸æˆæƒ</h4>
            <pre><code># å®‰å…¨è®¤è¯ç¤ºä¾‹
class SecureMCPServer(AdvancedMCPServer):
    def __init__(self, api_key: str, allowed_origins: List[str]):
        super().__init__()
        self.api_key = api_key
        self.allowed_origins = allowed_origins
        self.setup_security()
    
    def setup_security(self):
        @self.server.request_handler()
        async def handle_request(request):
            # éªŒè¯ API å¯†é’¥
            auth_header = request.headers.get("Authorization")
            if not auth_header or not auth_header.startswith("Bearer "):
                raise PermissionError("Missing or invalid authorization")
            
            token = auth_header[7:]  # Remove "Bearer "
            if token != self.api_key:
                raise PermissionError("Invalid API key")
            
            # éªŒè¯æ¥æº
            origin = request.headers.get("Origin")
            if origin and origin not in self.allowed_origins:
                raise PermissionError("Origin not allowed")
            
            return await super().handle_request(request)</code></pre>
        </div>

        <div class="practice-item">
            <h4>ğŸ›¡ï¸ æ•°æ®ä¿æŠ¤</h4>
            <pre><code># æ•°æ®åŠ å¯†å’Œè„±æ•
import hashlib
from cryptography.fernet import Fernet

class DataProtectionMixin:
    def __init__(self):
        self.encryption_key = Fernet.generate_key()
        self.cipher = Fernet(self.encryption_key)
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """åŠ å¯†æ•æ„Ÿæ•°æ®"""
        return self.cipher.encrypt(data.encode()).decode()
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """è§£å¯†æ•æ„Ÿæ•°æ®"""
        return self.cipher.decrypt(encrypted_data.encode()).decode()
    
    def hash_pii(self, pii_data: str) -> str:
        """å¯¹ä¸ªäººä¿¡æ¯è¿›è¡Œå“ˆå¸Œå¤„ç†"""
        return hashlib.sha256(pii_data.encode()).hexdigest()
    
    def sanitize_output(self, data: dict) -> dict:
        """æ¸…ç†è¾“å‡ºæ•°æ®ï¼Œç§»é™¤æ•æ„Ÿä¿¡æ¯"""
        sensitive_fields = ["password", "ssn", "credit_card"]
        
        sanitized = data.copy()
        for field in sensitive_fields:
            if field in sanitized:
                sanitized[field] = "***REDACTED***"
        
        return sanitized</code></pre>
        </div>
    </div>

    <h3>æ€§èƒ½ä¼˜åŒ–</h3>
    <pre><code># æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
import asyncio
from functools import lru_cache
import aioredis

class OptimizedMCPServer(SecureMCPServer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.redis_client = None
        self.setup_caching()
    
    async def setup_caching(self):
        """è®¾ç½®ç¼“å­˜ç³»ç»Ÿ"""
        self.redis_client = await aioredis.from_url("redis://localhost")
    
    @lru_cache(maxsize=128)
    def get_cached_resource(self, uri: str) -> str:
        """æœ¬åœ°ç¼“å­˜èµ„æº"""
        # å®ç°æœ¬åœ°ç¼“å­˜é€»è¾‘
        pass
    
    async def get_distributed_cache(self, key: str) -> Optional[str]:
        """åˆ†å¸ƒå¼ç¼“å­˜è·å–"""
        if self.redis_client:
            return await self.redis_client.get(key)
        return None
    
    async def set_distributed_cache(self, key: str, value: str, ttl: int = 3600):
        """åˆ†å¸ƒå¼ç¼“å­˜è®¾ç½®"""
        if self.redis_client:
            await self.redis_client.setex(key, ttl, value)
    
    async def batch_process_requests(self, requests: List[dict]) -> List[dict]:
        """æ‰¹é‡å¤„ç†è¯·æ±‚"""
        tasks = []
        for request in requests:
            task = asyncio.create_task(self.process_single_request(request))
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results
    
    async def process_single_request(self, request: dict) -> dict:
        """å¤„ç†å•ä¸ªè¯·æ±‚"""
        # å®ç°å…·ä½“çš„è¯·æ±‚å¤„ç†é€»è¾‘
        pass</code></pre>
</section>

<section class="tutorial-section">
    <h2>ç›‘æ§ä¸è°ƒè¯•</h2>

    <h3>æ—¥å¿—å’Œç›‘æ§</h3>
    <pre><code># ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ
import logging
import time
from prometheus_client import Counter, Histogram, Gauge
from functools import wraps

# Prometheus æŒ‡æ ‡
mcp_requests_total = Counter('mcp_requests_total', 'Total MCP requests', ['method', 'status'])
mcp_request_duration = Histogram('mcp_request_duration_seconds', 'MCP request duration')
mcp_active_connections = Gauge('mcp_active_connections', 'Active MCP connections')

class MonitoringMCPServer(OptimizedMCPServer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.setup_logging()
        self.active_connections = 0
    
    def setup_logging(self):
        """è®¾ç½®æ—¥å¿—ç³»ç»Ÿ"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('mcp_server.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def monitor_request(self, method_name: str):
        """è¯·æ±‚ç›‘æ§è£…é¥°å™¨"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                start_time = time.time()
                status = "success"
                
                try:
                    result = await func(*args, **kwargs)
                    return result
                except Exception as e:
                    status = "error"
                    self.logger.error(f"Error in {method_name}: {str(e)}")
                    raise
                finally:
                    duration = time.time() - start_time
                    mcp_requests_total.labels(method=method_name, status=status).inc()
                    mcp_request_duration.observe(duration)
                    
                    self.logger.info(f"{method_name} completed in {duration:.3f}s with status: {status}")
            
            return wrapper
        return decorator
    
    @monitor_request("list_resources")
    async def handle_list_resources(self) -> List[types.Resource]:
        """ç›‘æ§çš„èµ„æºåˆ—è¡¨å¤„ç†"""
        return await super().handle_list_resources()
    
    @monitor_request("call_tool")
    async def handle_call_tool(self, name: str, arguments: Dict[str, Any]) -> List[types.TextContent]:
        """ç›‘æ§çš„å·¥å…·è°ƒç”¨å¤„ç†"""
        return await super().handle_call_tool(name, arguments)
    
    async def handle_connection(self, read_stream, write_stream):
        """å¤„ç†è¿æ¥ï¼ŒåŒ…å«ç›‘æ§"""
        self.active_connections += 1
        mcp_active_connections.set(self.active_connections)
        
        try:
            await super().handle_connection(read_stream, write_stream)
        finally:
            self.active_connections -= 1
            mcp_active_connections.set(self.active_connections)
    
    def get_health_status(self) -> dict:
        """è·å–å¥åº·çŠ¶æ€"""
        return {
            "status": "healthy",
            "active_connections": self.active_connections,
            "uptime": time.time() - self.start_time,
            "version": "1.0.0"
        }</code></pre>

    <h3>è°ƒè¯•å·¥å…·</h3>
    <pre><code># è°ƒè¯•å’Œè¯Šæ–­å·¥å…·
class DebugMCPServer(MonitoringMCPServer):
    def __init__(self, *args, debug_mode: bool = False, **kwargs):
        super().__init__(*args, **kwargs)
        self.debug_mode = debug_mode
        self.request_history = []
    
    async def debug_request(self, request_data: dict):
        """è°ƒè¯•è¯·æ±‚æ•°æ®"""
        if self.debug_mode:
            self.request_history.append({
                "timestamp": time.time(),
                "request": request_data,
                "stack_trace": self.get_stack_trace() if self.debug_mode else None
            })
            
            # ä¿æŒå†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…
            if len(self.request_history) > 1000:
                self.request_history = self.request_history[-500:]
    
    def get_stack_trace(self) -> str:
        """è·å–è°ƒç”¨æ ˆ"""
        import traceback
        return traceback.format_stack()
    
    def get_debug_info(self) -> dict:
        """è·å–è°ƒè¯•ä¿¡æ¯"""
        return {
            "debug_mode": self.debug_mode,
            "request_history_count": len(self.request_history),
            "recent_requests": self.request_history[-10:] if self.debug_mode else [],
            "server_stats": self.get_health_status()
        }
    
    async def export_debug_data(self, format_type: str = "json") -> str:
        """å¯¼å‡ºè°ƒè¯•æ•°æ®"""
        debug_data = {
            "server_info": self.get_debug_info(),
            "request_history": self.request_history,
            "exported_at": time.time()
        }
        
        if format_type == "json":
            return json.dumps(debug_data, indent=2, default=str)
        elif format_type == "csv":
            # ç®€åŒ–çš„ CSV å¯¼å‡º
            import csv
            import io
            
            output = io.StringIO()
            writer = csv.writer(output)
            
            writer.writerow(["timestamp", "request_type", "status"])
            for req in self.request_history:
                writer.writerow([
                    req["timestamp"],
                    req["request"].get("method", "unknown"),
                    "completed"
                ])
            
            return output.getvalue()
        
        return str(debug_data)</code></pre>
</section>

<section class="tutorial-section">
    <h2>å®é™…åº”ç”¨åœºæ™¯</h2>

    <div class="application-scenarios">
        <div class="scenario-card">
            <h3>ğŸ¢ ä¼ä¸šæ•°æ®é›†æˆ</h3>
            <p>è¿æ¥ä¼ä¸šå†…éƒ¨ç³»ç»Ÿï¼Œå®ç°æ•°æ®ç»Ÿä¸€è®¿é—®</p>
            <ul>
                <li>CRM ç³»ç»Ÿé›†æˆ</li>
                <li>ERP æ•°æ®è®¿é—®</li>
                <li>è´¢åŠ¡ç³»ç»Ÿå¯¹æ¥</li>
                <li>äººåŠ›èµ„æºç®¡ç†</li>
            </ul>
        </div>

        <div class="scenario-card">
            <h3>ğŸ”¬ ç ”å‘å·¥å…·é“¾</h3>
            <p>é›†æˆå¼€å‘å·¥å…·å’ŒæœåŠ¡ï¼Œæå‡ç ”å‘æ•ˆç‡</p>
            <ul>
                <li>ä»£ç ä»“åº“è®¿é—®</li>
                <li>CI/CD æµæ°´çº¿</li>
                <li>é—®é¢˜è·Ÿè¸ªç³»ç»Ÿ</li>
                <li>æ–‡æ¡£ç®¡ç†å¹³å°</li>
            </ul>
        </div>

        <div class="scenario-card">
            <h3>ğŸ“Š æ•°æ®åˆ†æå¹³å°</h3>
            <p>è¿æ¥å„ç§æ•°æ®æºï¼Œæ”¯æŒæ™ºèƒ½åˆ†æ</p>
            <ul>
                <li>æ•°æ®åº“æŸ¥è¯¢</li>
                <li>API æ•°æ®è·å–</li>
                <li>æ–‡ä»¶ç³»ç»Ÿè®¿é—®</li>
                <li>å®æ—¶æ•°æ®æµ</li>
            </ul>
        </div>
    </div>
</section>

<section class="tutorial-section">
    <h2>æ€»ç»“ä¸å±•æœ›</h2>

    <div class="key-takeaways">
        <h4>MCP é›†æˆå…³é”®è¦ç‚¹ï¼š</h4>
        <ul>
            <li>âœ… æ ‡å‡†åŒ–çš„ AI åº”ç”¨é›†æˆåè®®</li>
            <li>âœ… å®‰å…¨å¯æ§çš„å¤–éƒ¨ç³»ç»Ÿè®¿é—®</li>
            <li>âœ… çµæ´»çš„èµ„æºå’Œå·¥å…·ç®¡ç†</li>
            <li>âœ… é«˜æ•ˆçš„ä¸Šä¸‹æ–‡å…±äº«æœºåˆ¶</li>
            <li>âœ… å®Œå–„çš„ç›‘æ§å’Œè°ƒè¯•æ”¯æŒ</li>
            <li>âœ… å¹¿æ³›çš„åº”ç”¨åœºæ™¯å’Œæ‰©å±•æ€§</li>
        </ul>
    </div>

    <div class="alert alert-success">
        <strong>æŠ€æœ¯å‰æ™¯ï¼š</strong>MCP åè®®ä¸º AI åº”ç”¨çš„ç”Ÿæ€ç³»ç»Ÿå»ºè®¾å¥ å®šäº†åŸºç¡€ï¼Œéšç€æ›´å¤šå·¥å…·å’ŒæœåŠ¡çš„æ”¯æŒï¼Œå°†æå¤§åœ°æ‰©å±• Claude çš„èƒ½åŠ›è¾¹ç•Œï¼Œå®ç°çœŸæ­£çš„æ™ºèƒ½åŒ–å·¥ä½œæµç¨‹ã€‚
    </div>
</section>
</div>

<footer class="tutorial-footer">
    <div class="tutorial-navigation">
        <a href="claude-computer-use.html" class="nav-link prev">
            â† ä¸Šä¸€ç¯‡ï¼šClaude Computer Use åŠŸèƒ½è§£æ
        </a>
        <a href="ai-coding-trends-2024.html" class="nav-link next">
            ä¸‹ä¸€ç¯‡ï¼š2024 AI ç¼–ç¨‹è¶‹åŠ¿åˆ†æ â†’
        </a>
    </div>

    <div class="tutorial-tags">
        <span class="tag">MCP</span>
        <span class="tag">åè®®é›†æˆ</span>
        <span class="tag">æ¨¡å‹åä½œ</span>
        <span class="tag">ç³»ç»Ÿé›†æˆ</span>
        <span class="tag">ä¼ä¸šåº”ç”¨</span>
    </div>
</footer>
</article>
</div>
</main>

    <div id="footer-placeholder"></div>

    <script src="../scripts/load-footer.js"></script>
    <script src="../scripts/wechat-share.js"></script>
</body>

</html>